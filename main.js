/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => JournalPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/models/types.ts
var DEFAULT_SETTINGS = {
  sourceFolder: "Daily Notes",
  dateFormat: "YYYY-MM-DD",
  destinationFolder: "Journal",
  journalFileNameFormat: "Journal-YYYY-MM-DD.md",
  aiProvider: "openai",
  aiConfig: {
    apiKey: "",
    endpoint: "",
    model: "gpt-3.5-turbo"
  },
  outputLanguage: "auto",
  checkFrequency: 60,
  customPrompt: `Transform these raw daily log entries into a well-written, engaging journal entry.

Guidelines:
- Write in a candid, personal style with storytelling elements
- Maintain chronological flow of the day's events
- Include emotional context and personal reflections
- Preserve the original language and tone
- Create engaging prose that captures the day's essence
- Keep the same perspective (first person)
- Make it feel authentic and re-readable in the future

SENTIMENT ANALYSIS:
- Analyze the overall emotional tone of the day based on the entries
- Consider the context, activities, and expressed emotions
- Determine the dominant sentiment from: Very Happy, Happy, Neutral, Sad, Very Sad

IMPORTANT OUTPUT REQUIREMENTS:
- Return ONLY the journal entry content followed by the sentiment analysis
- Format the sentiment as: SENTIMENT: [one of: Very Happy, Happy, Neutral, Sad, Very Sad]
- Place the SENTIMENT line at the very end, after the journal content
- Do NOT include any introductions, explanations, or meta-commentary
- Do NOT start with phrases like "Here's today's journal" or "Aqu\xED va el diario"
- Do NOT add closing remarks or signatures beyond the sentiment line
- Start directly with the journal content

Raw entries:
{content}

Create the journal entry now (content only, no introductions):`
};

// src/settings/settingsTab.ts
var import_obsidian = require("obsidian");

// src/utils/logger.ts
var Logger = class {
  constructor() {
    this.logLevel = 1 /* INFO */;
    this.prefix = "[Journal Plugin]";
  }
  static getInstance() {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  setLogLevel(level) {
    this.logLevel = level;
  }
  debug(message, ...args) {
    if (this.logLevel <= 0 /* DEBUG */) {
      console.debug(`${this.prefix} [DEBUG]`, message, ...args);
    }
  }
  info(message, ...args) {
    if (this.logLevel <= 1 /* INFO */) {
      console.info(`${this.prefix} [INFO]`, message, ...args);
    }
  }
  warn(message, ...args) {
    if (this.logLevel <= 2 /* WARN */) {
      console.warn(`${this.prefix} [WARN]`, message, ...args);
    }
  }
  error(message, error, ...args) {
    if (this.logLevel <= 3 /* ERROR */) {
      console.error(`${this.prefix} [ERROR]`, message, error, ...args);
    }
  }
  logAIRequest(provider, model, inputLength) {
    this.debug(`AI Request: ${provider}/${model}, input length: ${inputLength} chars`);
  }
  logAIResponse(provider, outputLength, duration) {
    this.debug(`AI Response: ${provider}, output length: ${outputLength} chars, duration: ${duration}ms`);
  }
  logFileOperation(operation, filePath) {
    this.debug(`File ${operation}: ${filePath}`);
  }
  logProcessingStats(processed, skipped, errors) {
    this.info(`Processing complete: ${processed} processed, ${skipped} skipped, ${errors} errors`);
  }
};
var logger = Logger.getInstance();

// src/services/ai/aiService.ts
var AIService = class {
  constructor(provider, config) {
    this.provider = provider;
    this.config = config;
  }
  /**
   * Make HTTP request with error handling and retry logic
   */
  async makeHttpRequest(url, options, retries = 3, timeout = 3e4) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
      for (let attempt = 1; attempt <= retries; attempt++) {
        try {
          logger.debug(`Making request to ${url} (attempt ${attempt}/${retries})`);
          const response = await fetch(url, {
            ...options,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            if (attempt === retries) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const delay = Math.min(1e3 * Math.pow(2, attempt - 1), 1e4);
            await this.sleep(delay);
            continue;
          }
          return response;
        } catch (error) {
          if (attempt === retries) {
            throw error;
          }
          logger.warn(`Request attempt ${attempt} failed:`, error);
          const delay = Math.min(1e3 * Math.pow(2, attempt - 1), 1e4);
          await this.sleep(delay);
        }
      }
      throw new Error("All retry attempts failed");
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          throw new Error(`Request timeout after ${timeout}ms`);
        }
      }
      throw error;
    }
  }
  /**
   * Handle common API errors
   */
  handleApiError(error, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    logger.error(`${this.provider} API error in ${context}:`, error);
    if ((_a = error.message) == null ? void 0 : _a.includes("timeout")) {
      throw new Error(`${this.getDisplayName()} request timed out. Please try again.`);
    }
    if (((_b = error.message) == null ? void 0 : _b.includes("401")) || ((_c = error.message) == null ? void 0 : _c.includes("403"))) {
      throw new Error(`${this.getDisplayName()} authentication failed. Please check your API key.`);
    }
    if ((_d = error.message) == null ? void 0 : _d.includes("429")) {
      throw new Error(`${this.getDisplayName()} rate limit exceeded. Please wait before trying again.`);
    }
    if (((_e = error.message) == null ? void 0 : _e.includes("500")) || ((_f = error.message) == null ? void 0 : _f.includes("502")) || ((_g = error.message) == null ? void 0 : _g.includes("503"))) {
      throw new Error(`${this.getDisplayName()} server error. Please try again later.`);
    }
    throw new Error(`${this.getDisplayName()} error: ${error.message || "Unknown error"}`);
  }
  /**
   * Sleep utility for retry delays
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Sanitize and prepare prompt with content
   */
  preparePrompt(template, content, language) {
    let prompt = template.replace("{content}", content.trim());
    if (language && language !== "auto") {
      prompt += `

Please write the journal entry in ${language}. Return only the journal content, no introductions or explanations.`;
    } else if (!language) {
      prompt += `

IMPORTANT: Write the journal entry in the same language as the original content. Do not translate or change the language. Return only the journal content, no introductions or explanations.`;
    }
    return prompt;
  }
  /**
   * Parse sentiment and content from AI response
   */
  parseSentimentFromResponse(response) {
    const lines = response.trim().split("\n");
    let content = response.trim();
    let sentiment;
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      const sentimentMatch = line.match(/^SENTIMENT:\s*(Very Happy|Happy|Neutral|Sad|Very Sad)$/i);
      if (sentimentMatch) {
        const parsedSentiment = sentimentMatch[1].trim();
        const validSentiments = ["Very Happy", "Happy", "Neutral", "Sad", "Very Sad"];
        const normalizedSentiment = validSentiments.find(
          (s) => s.toLowerCase() === parsedSentiment.toLowerCase()
        );
        if (normalizedSentiment) {
          sentiment = normalizedSentiment;
          content = lines.slice(0, i).join("\n").trim();
          logger.debug(`Parsed sentiment: ${sentiment}`);
          break;
        } else {
          logger.warn(`Invalid sentiment value parsed: ${parsedSentiment}`);
        }
      }
    }
    if (!sentiment) {
      logger.debug("No sentiment found in response, defaulting to Neutral");
      sentiment = "Neutral";
    }
    return { content, sentiment };
  }
  /**
   * Validate response content
   */
  validateResponse(response) {
    if (!response || response.trim().length === 0) {
      throw new Error("Received empty response from AI service");
    }
    const trimmed = response.trim();
    if (trimmed.length < 50) {
      logger.warn("Received unusually short response from AI service:", trimmed);
    }
    return trimmed;
  }
};

// src/services/ai/openaiService.ts
var OpenAIService = class extends AIService {
  constructor(config) {
    super("openai", config);
    this.baseUrl = "https://api.openai.com/v1/chat/completions";
  }
  async processContent(content, prompt, language) {
    var _a;
    const startTime = Date.now();
    try {
      logger.logAIRequest(this.provider, this.config.model, content.length);
      const fullPrompt = this.preparePrompt(prompt, content, language);
      const response = await this.makeHttpRequest(this.baseUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: this.config.model,
          messages: [
            {
              role: "user",
              content: fullPrompt
            }
          ],
          temperature: 0.7,
          max_tokens: 2e3,
          top_p: 1,
          frequency_penalty: 0,
          presence_penalty: 0
        })
      });
      const data = await response.json();
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No response generated");
      }
      const generatedContent = (_a = data.choices[0].message) == null ? void 0 : _a.content;
      if (!generatedContent) {
        throw new Error("Empty response from OpenAI");
      }
      const validatedResponse = this.validateResponse(generatedContent);
      const result = this.parseSentimentFromResponse(validatedResponse);
      const duration = Date.now() - startTime;
      logger.logAIResponse(this.provider, result.content.length, duration);
      return result;
    } catch (error) {
      this.handleApiError(error, "processContent");
    }
  }
  async testConnection() {
    try {
      const response = await this.makeHttpRequest("https://api.openai.com/v1/models", {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.config.apiKey}`
        }
      });
      const data = await response.json();
      return data.data && Array.isArray(data.data);
    } catch (error) {
      logger.error("OpenAI connection test failed:", error);
      return false;
    }
  }
  /**
   * Fetch available models from OpenAI API
   */
  async getAvailableModels() {
    try {
      const response = await this.makeHttpRequest("https://api.openai.com/v1/models", {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.config.apiKey}`
        }
      });
      const data = await response.json();
      if (data.data && Array.isArray(data.data)) {
        const models = data.data.filter((model) => {
          const id = model.id.toLowerCase();
          return id.includes("gpt") && !id.includes("instruct") && !id.includes("edit");
        }).map((model) => model.id).sort();
        return models.length > 0 ? models : OpenAIService.getAvailableModels();
      }
      return OpenAIService.getAvailableModels();
    } catch (error) {
      logger.error("Failed to fetch OpenAI models:", error);
      return OpenAIService.getAvailableModels();
    }
  }
  getDisplayName() {
    return `OpenAI (${this.config.model})`;
  }
  validateConfig() {
    const errors = [];
    if (!this.config.apiKey) {
      errors.push("API Key is required for OpenAI");
    }
    if (!this.config.model) {
      errors.push("Model is required for OpenAI");
    }
    if (this.config.apiKey && !this.config.apiKey.startsWith("sk-")) {
      errors.push('OpenAI API Key should start with "sk-"');
    }
    return errors;
  }
  /**
   * Get available models for OpenAI
   */
  static getAvailableModels() {
    return [
      "gpt-4",
      "gpt-4-turbo-preview",
      "gpt-3.5-turbo",
      "gpt-3.5-turbo-16k"
    ];
  }
};

// src/services/ai/geminiService.ts
var GeminiService = class extends AIService {
  constructor(config) {
    super("gemini", config);
    this.baseUrl = "https://generativelanguage.googleapis.com/v1beta/models";
  }
  async processContent(content, prompt, language) {
    const startTime = Date.now();
    try {
      logger.logAIRequest(this.provider, this.config.model, content.length);
      const fullPrompt = this.preparePrompt(prompt, content, language);
      const url = `${this.baseUrl}/${this.config.model}:generateContent?key=${this.config.apiKey}`;
      const response = await this.makeHttpRequest(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: fullPrompt
                }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
            stopSequences: []
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });
      const data = await response.json();
      if (!data.candidates || data.candidates.length === 0) {
        throw new Error("No response generated from Gemini");
      }
      const candidate = data.candidates[0];
      if (candidate.finishReason === "SAFETY") {
        throw new Error("Content was blocked by Gemini safety filters");
      }
      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        throw new Error("Empty response from Gemini");
      }
      const generatedContent = candidate.content.parts[0].text;
      if (!generatedContent) {
        throw new Error("No text content in Gemini response");
      }
      const validatedResponse = this.validateResponse(generatedContent);
      const result = this.parseSentimentFromResponse(validatedResponse);
      const duration = Date.now() - startTime;
      logger.logAIResponse(this.provider, result.content.length, duration);
      return result;
    } catch (error) {
      this.handleApiError(error, "processContent");
    }
  }
  async testConnection() {
    try {
      const url = `${this.baseUrl}?key=${this.config.apiKey}`;
      const response = await this.makeHttpRequest(url, {
        method: "GET"
      });
      const data = await response.json();
      return data.models && Array.isArray(data.models);
    } catch (error) {
      logger.error("Gemini connection test failed:", error);
      return false;
    }
  }
  /**
   * Fetch available models from Gemini API
   */
  async getAvailableModels() {
    try {
      const url = `${this.baseUrl}?key=${this.config.apiKey}`;
      const response = await this.makeHttpRequest(url, {
        method: "GET"
      });
      const data = await response.json();
      if (data.models && Array.isArray(data.models)) {
        const models = data.models.filter((model) => {
          const name = model.name.toLowerCase();
          return name.includes("gemini") && (name.includes("generatecontent") || name.includes("models/gemini"));
        }).map((model) => {
          const parts = model.name.split("/");
          return parts[parts.length - 1];
        }).filter((name) => name && !name.includes(":")).sort();
        return models.length > 0 ? models : GeminiService.getAvailableModels();
      }
      return GeminiService.getAvailableModels();
    } catch (error) {
      logger.error("Failed to fetch Gemini models:", error);
      return GeminiService.getAvailableModels();
    }
  }
  getDisplayName() {
    return `Google Gemini (${this.config.model})`;
  }
  validateConfig() {
    const errors = [];
    if (!this.config.apiKey) {
      errors.push("API Key is required for Google Gemini");
    }
    if (!this.config.model) {
      errors.push("Model is required for Google Gemini");
    }
    if (this.config.apiKey && this.config.apiKey.length < 30) {
      errors.push("Google Gemini API Key appears to be invalid");
    }
    return errors;
  }
  /**
   * Get available models for Gemini
   */
  static getAvailableModels() {
    return [
      "gemini-1.5-pro-latest",
      "gemini-1.5-flash-latest",
      "gemini-pro",
      "gemini-pro-1.5"
    ];
  }
};

// src/services/ai/ollamaService.ts
var OllamaService = class extends AIService {
  constructor(config) {
    super("ollama", config);
    this.defaultEndpoint = "http://localhost:11434";
    if (!this.config.endpoint) {
      this.config.endpoint = this.defaultEndpoint;
    }
  }
  async processContent(content, prompt, language) {
    const startTime = Date.now();
    try {
      logger.logAIRequest(this.provider, this.config.model, content.length);
      const fullPrompt = this.preparePrompt(prompt, content, language);
      const url = `${this.config.endpoint}/api/generate`;
      const response = await this.makeHttpRequest(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.config.model,
          prompt: fullPrompt,
          stream: false,
          options: {
            temperature: 0.7,
            top_p: 0.9,
            top_k: 40,
            num_predict: 2e3
          }
        })
      }, 3, 6e4);
      const data = await response.json();
      if (!data.response) {
        throw new Error("Empty response from Ollama");
      }
      const validatedResponse = this.validateResponse(data.response);
      const result = this.parseSentimentFromResponse(validatedResponse);
      const duration = Date.now() - startTime;
      logger.logAIResponse(this.provider, result.content.length, duration);
      return result;
    } catch (error) {
      this.handleApiError(error, "processContent");
    }
  }
  async testConnection() {
    try {
      const url = `${this.config.endpoint}/api/tags`;
      const response = await this.makeHttpRequest(url, {
        method: "GET"
      }, 1, 5e3);
      const data = await response.json();
      return data.models && Array.isArray(data.models);
    } catch (error) {
      logger.error("Ollama connection test failed:", error);
      return false;
    }
  }
  /**
   * Fetch available models from Ollama server
   */
  async getAvailableModels() {
    try {
      const url = `${this.config.endpoint}/api/tags`;
      const response = await this.makeHttpRequest(url, {
        method: "GET"
      });
      const data = await response.json();
      if (data.models && Array.isArray(data.models)) {
        return data.models.map((model) => model.name).filter((name) => name && name.trim()).sort();
      }
      return [];
    } catch (error) {
      logger.error("Failed to fetch Ollama models:", error);
      return OllamaService.getCommonModels();
    }
  }
  getDisplayName() {
    return `Ollama (${this.config.model})`;
  }
  validateConfig() {
    const errors = [];
    if (!this.config.model) {
      errors.push("Model is required for Ollama");
    }
    if (!this.config.endpoint) {
      errors.push("Endpoint is required for Ollama");
    }
    if (this.config.endpoint) {
      try {
        new URL(this.config.endpoint);
      } catch (e) {
        errors.push("Invalid endpoint URL for Ollama");
      }
    }
    return errors;
  }
  /**
   * Get common Ollama models
   */
  static getCommonModels() {
    return [
      "llama2",
      "llama2:13b",
      "llama2:70b",
      "mistral",
      "mixtral",
      "codellama",
      "gemma",
      "qwen",
      "phi"
    ];
  }
  /**
   * Check if a specific model is available
   */
  async isModelAvailable(modelName) {
    try {
      const models = await this.getAvailableModels();
      return models.some((model) => model.includes(modelName));
    } catch (e) {
      return false;
    }
  }
  /**
   * Pull a model if it's not available
   */
  async pullModel(modelName) {
    try {
      const url = `${this.config.endpoint}/api/pull`;
      await this.makeHttpRequest(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: modelName
        })
      }, 1, 3e5);
      logger.info(`Successfully pulled Ollama model: ${modelName}`);
    } catch (error) {
      logger.error(`Failed to pull Ollama model ${modelName}:`, error);
      throw new Error(`Failed to pull model ${modelName}: ${error.message}`);
    }
  }
};

// src/services/ai/aiServiceFactory.ts
var AIServiceFactory = class {
  /**
   * Create an AI service instance based on the provider
   */
  static createService(provider, config) {
    logger.debug(`Creating AI service for provider: ${provider}`);
    switch (provider) {
      case "openai":
        return new OpenAIService(config);
      case "gemini":
        return new GeminiService(config);
      case "ollama":
        return new OllamaService(config);
      default:
        throw new Error(`Unsupported AI provider: ${provider}`);
    }
  }
  /**
   * Get available models for a specific provider (static fallback)
   */
  static getAvailableModels(provider) {
    switch (provider) {
      case "openai":
        return OpenAIService.getAvailableModels();
      case "gemini":
        return GeminiService.getAvailableModels();
      case "ollama":
        return OllamaService.getCommonModels();
      default:
        return [];
    }
  }
  /**
   * Fetch available models dynamically from the actual service endpoint
   */
  static async fetchAvailableModels(provider, config) {
    try {
      logger.debug(`Fetching available models for ${provider}`);
      const service = this.createService(provider, config);
      if ("getAvailableModels" in service && typeof service.getAvailableModels === "function") {
        const models = await service.getAvailableModels();
        return {
          success: true,
          models: models || []
        };
      }
      const staticModels = this.getAvailableModels(provider);
      return {
        success: true,
        models: staticModels
      };
    } catch (error) {
      logger.error(`Failed to fetch models for ${provider}:`, error);
      const fallbackModels = this.getAvailableModels(provider);
      return {
        success: false,
        models: fallbackModels,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Get fallback models when dynamic fetching fails
   */
  static getFallbackModels(provider) {
    return this.getAvailableModels(provider);
  }
  /**
   * Get provider display name
   */
  static getProviderDisplayName(provider) {
    switch (provider) {
      case "openai":
        return "OpenAI";
      case "gemini":
        return "Google Gemini";
      case "ollama":
        return "Ollama (Local)";
      default:
        return provider;
    }
  }
  /**
   * Get configuration requirements for a provider
   */
  static getProviderRequirements(provider) {
    switch (provider) {
      case "openai":
        return {
          requiresApiKey: true,
          requiresEndpoint: false,
          requiresModel: true,
          description: "Requires an OpenAI API key. Sign up at https://platform.openai.com/"
        };
      case "gemini":
        return {
          requiresApiKey: true,
          requiresEndpoint: false,
          requiresModel: true,
          description: "Requires a Google AI Studio API key. Get one at https://makersuite.google.com/"
        };
      case "ollama":
        return {
          requiresApiKey: false,
          requiresEndpoint: true,
          requiresModel: true,
          description: "Requires Ollama running locally. Install from https://ollama.ai/"
        };
      default:
        return {
          requiresApiKey: false,
          requiresEndpoint: false,
          requiresModel: false,
          description: "Unknown provider"
        };
    }
  }
  /**
   * Validate configuration for a specific provider
   */
  static validateConfiguration(provider, config) {
    const service = this.createService(provider, config);
    return service.validateConfig();
  }
  /**
   * Test connection for a specific provider configuration
   */
  static async testConnection(provider, config) {
    try {
      const service = this.createService(provider, config);
      const success = await service.testConnection();
      return { success };
    } catch (error) {
      logger.error(`Connection test failed for ${provider}:`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Get all supported providers
   */
  static getSupportedProviders() {
    return ["openai", "gemini", "ollama"];
  }
};

// src/settings/settingsTab.ts
var FolderSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, onSelect) {
    super(app);
    this.onSelect = onSelect;
    this.setPlaceholder("Type to search folders...");
  }
  getItems() {
    const folders = [];
    const addFolder = (folder) => {
      folders.push(folder);
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian.TFolder) {
          addFolder(child);
        }
      });
    };
    const rootFolder = this.app.vault.getRoot();
    rootFolder.children.forEach((child) => {
      if (child instanceof import_obsidian.TFolder) {
        addFolder(child);
      }
    });
    folders.sort((a, b) => a.path.localeCompare(b.path));
    return folders;
  }
  getItemText(folder) {
    return folder.path;
  }
  renderSuggestion(value, el) {
    const folder = value.item;
    el.createEl("div", { text: folder.name, cls: "suggestion-title" });
    if (folder.path !== folder.name) {
      el.createEl("small", {
        text: folder.path,
        cls: "suggestion-note"
      });
    }
    const fileCount = folder.children.filter((child) => child.name.endsWith(".md")).length;
    const folderCount = folder.children.filter((child) => child instanceof import_obsidian.TFolder).length;
    if (fileCount > 0 || folderCount > 0) {
      const countText = [];
      if (fileCount > 0)
        countText.push(`${fileCount} files`);
      if (folderCount > 0)
        countText.push(`${folderCount} folders`);
      el.createEl("small", {
        text: countText.join(", "),
        cls: "suggestion-aux"
      });
    }
  }
  onChooseItem(folder) {
    this.onSelect(folder);
  }
};
var FolderSuggest = class {
  constructor(app, textComponent, onSelect) {
    this.app = app;
    this.textComponent = textComponent;
    this.onSelect = onSelect;
    this.setupSuggestion();
  }
  setupSuggestion() {
    const containerEl = this.textComponent.inputEl.parentElement;
    if (containerEl) {
      const buttonContainer = containerEl.createEl("div", {
        cls: "setting-item-control-button-container"
      });
      buttonContainer.style.display = "inline-flex";
      buttonContainer.style.alignItems = "center";
      buttonContainer.style.marginLeft = "8px";
      const button = buttonContainer.createEl("button", {
        text: "\u{1F4C1}",
        title: "Browse folders (Click to select from existing folders)",
        cls: "clickable-icon setting-folder-suggest-button"
      });
      button.style.padding = "6px 10px";
      button.style.border = "1px solid var(--background-modifier-border)";
      button.style.borderRadius = "6px";
      button.style.background = "var(--interactive-normal)";
      button.style.color = "var(--text-normal)";
      button.style.cursor = "pointer";
      button.style.fontSize = "14px";
      button.style.display = "flex";
      button.style.alignItems = "center";
      button.style.justifyContent = "center";
      button.style.minWidth = "32px";
      button.style.height = "32px";
      button.addEventListener("click", (e) => {
        e.preventDefault();
        const modal = new FolderSuggestModal(this.app, (folder) => {
          this.textComponent.setValue(folder.path);
          this.onSelect(folder.path);
          this.validateFolder(folder.path);
        });
        modal.open();
      });
      button.addEventListener("mouseenter", () => {
        button.style.background = "var(--interactive-hover)";
        button.style.borderColor = "var(--interactive-accent)";
      });
      button.addEventListener("mouseleave", () => {
        button.style.background = "var(--interactive-normal)";
        button.style.borderColor = "var(--background-modifier-border)";
      });
      this.textComponent.inputEl.addEventListener("input", () => {
        setTimeout(() => this.validateFolder(this.textComponent.getValue()), 100);
      });
      setTimeout(() => this.validateFolder(this.textComponent.getValue()), 100);
    }
    this.textComponent.inputEl.placeholder = "e.g., Daily Notes";
    this.textComponent.inputEl.title = "Enter folder path manually or click \u{1F4C1} to browse existing folders";
  }
  validateFolder(path) {
    var _a, _b, _c;
    if (!path.trim())
      return;
    const folder = this.app.vault.getAbstractFileByPath(path);
    const inputEl = this.textComponent.inputEl;
    inputEl.classList.remove("folder-valid", "folder-invalid");
    const existingMsg = (_a = inputEl.parentElement) == null ? void 0 : _a.querySelector(".folder-validation-msg");
    if (existingMsg) {
      existingMsg.remove();
    }
    if (folder instanceof import_obsidian.TFolder) {
      inputEl.classList.add("folder-valid");
      inputEl.style.borderColor = "var(--color-green)";
      const fileCount = folder.children.filter((child) => child.name.endsWith(".md")).length;
      if (fileCount > 0) {
        const msg = (_b = inputEl.parentElement) == null ? void 0 : _b.createEl("small", {
          text: `\u2705 Found ${fileCount} markdown files`,
          cls: "folder-validation-msg"
        });
        if (msg) {
          msg.style.color = "var(--color-green)";
          msg.style.display = "block";
          msg.style.marginTop = "4px";
          msg.style.fontSize = "12px";
        }
      }
    } else {
      inputEl.classList.add("folder-invalid");
      inputEl.style.borderColor = "var(--color-orange)";
      const msg = (_c = inputEl.parentElement) == null ? void 0 : _c.createEl("small", {
        text: `\u26A0\uFE0F Folder doesn't exist yet (will be created)`,
        cls: "folder-validation-msg"
      });
      if (msg) {
        msg.style.color = "var(--color-orange)";
        msg.style.display = "block";
        msg.style.marginTop = "4px";
        msg.style.fontSize = "12px";
      }
    }
  }
};
var JournalPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Daily Notes to Journal - Settings" });
    this.addBasicSettings();
    this.addAISettings();
    this.addSchedulingSettings();
    this.addAdvancedSettings();
    this.addActionButtons();
  }
  addBasicSettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Basic Settings" });
    new import_obsidian.Setting(containerEl).setName("Source folder").setDesc("Folder containing your daily notes").addText((text) => {
      text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.sourceFolder).onChange(async (value) => {
        this.plugin.settings.sourceFolder = value.trim() || "Daily Notes";
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, text, async (value) => {
        this.plugin.settings.sourceFolder = value || "Daily Notes";
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Date format").setDesc("Date format used in daily note filenames (e.g., YYYY-MM-DD)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value.trim() || "YYYY-MM-DD";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Journal folder").setDesc("Folder where journal entries will be created").addText((text) => {
      text.setPlaceholder("Journal").setValue(this.plugin.settings.destinationFolder).onChange(async (value) => {
        this.plugin.settings.destinationFolder = value.trim() || "Journal";
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, text, async (value) => {
        this.plugin.settings.destinationFolder = value || "Journal";
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Journal filename format").setDesc("Format for journal entry filenames (supports date formatting)").addText((text) => text.setPlaceholder("Journal-YYYY-MM-DD.md").setValue(this.plugin.settings.journalFileNameFormat).onChange(async (value) => {
      this.plugin.settings.journalFileNameFormat = value.trim() || "Journal-YYYY-MM-DD.md";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Output language").setDesc("Language for journal entries (auto = detect from source)").addDropdown((dropdown) => dropdown.addOption("auto", "Auto-detect").addOption("en", "English").addOption("es", "Spanish").addOption("fr", "French").addOption("de", "German").addOption("it", "Italian").addOption("pt", "Portuguese").addOption("ru", "Russian").addOption("ja", "Japanese").addOption("ko", "Korean").addOption("zh", "Chinese").setValue(this.plugin.settings.outputLanguage).onChange(async (value) => {
      this.plugin.settings.outputLanguage = value;
      await this.plugin.saveSettings();
    }));
  }
  addAISettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "AI Configuration" });
    let providerDropdown;
    let modelDropdown;
    let modelRefreshButton;
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Choose your AI service provider").addDropdown((dropdown) => {
      providerDropdown = dropdown;
      dropdown.addOption("openai", "OpenAI").addOption("gemini", "Google Gemini").addOption("ollama", "Ollama (Local)").setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
        this.plugin.settings.aiProvider = value;
        const fallbackModels = AIServiceFactory.getFallbackModels(value);
        this.plugin.settings.aiConfig.model = fallbackModels[0] || "";
        this.plugin.settings.aiConfig.apiKey = "";
        this.plugin.settings.aiConfig.endpoint = value === "ollama" ? "http://localhost:11434" : "";
        await this.plugin.saveSettings();
        this.updateModelDropdown(modelDropdown, value, fallbackModels);
        this.refreshAIConfigSettings();
        this.fetchAndUpdateModels(value, modelDropdown, modelRefreshButton);
      });
    });
    const modelSetting = new import_obsidian.Setting(containerEl).setName("Model").setDesc("AI model to use for processing");
    modelSetting.addDropdown((dropdown) => {
      modelDropdown = dropdown;
      const fallbackModels = AIServiceFactory.getFallbackModels(this.plugin.settings.aiProvider);
      this.updateModelDropdown(dropdown, this.plugin.settings.aiProvider, fallbackModels);
      dropdown.setValue(this.plugin.settings.aiConfig.model).onChange(async (value) => {
        this.plugin.settings.aiConfig.model = value;
        await this.plugin.saveSettings();
      });
    });
    modelSetting.addButton((button) => {
      modelRefreshButton = button.buttonEl;
      button.setButtonText("\u{1F504}").setTooltip("Refresh available models from endpoint").onClick(async () => {
        await this.refreshModels(modelDropdown, modelRefreshButton);
      });
      button.buttonEl.style.marginLeft = "8px";
      button.buttonEl.style.padding = "6px 10px";
      button.buttonEl.style.borderRadius = "6px";
      button.buttonEl.style.fontSize = "14px";
    });
    this.aiConfigContainer = containerEl.createDiv();
    this.refreshAIConfigSettings();
    setTimeout(() => {
      this.fetchAndUpdateModels(this.plugin.settings.aiProvider, modelDropdown, modelRefreshButton);
    }, 100);
  }
  updateModelDropdown(dropdown, provider, models) {
    dropdown.selectEl.empty();
    const modelList = models || AIServiceFactory.getFallbackModels(provider);
    if (modelList.length === 0) {
      dropdown.addOption("", "No models available");
      return;
    }
    modelList.forEach((model) => {
      dropdown.addOption(model, model);
    });
  }
  /**
   * Fetch and update models for a specific provider
   */
  async fetchAndUpdateModels(provider, dropdown, refreshButton) {
    const requirements = AIServiceFactory.getProviderRequirements(provider);
    if (requirements.requiresApiKey && !this.plugin.settings.aiConfig.apiKey) {
      return;
    }
    if (requirements.requiresEndpoint && !this.plugin.settings.aiConfig.endpoint) {
      return;
    }
    try {
      const result = await AIServiceFactory.fetchAvailableModels(provider, this.plugin.settings.aiConfig);
      if (result.success && result.models.length > 0) {
        this.updateModelDropdown(dropdown, provider, result.models);
        const currentModel = this.plugin.settings.aiConfig.model;
        if (!result.models.includes(currentModel) && result.models.length > 0) {
          this.plugin.settings.aiConfig.model = result.models[0];
          dropdown.setValue(result.models[0]);
          await this.plugin.saveSettings();
        }
        this.showModelRefreshStatus(refreshButton, true, `Found ${result.models.length} models`);
      } else {
        const message = result.error || "No models available";
        this.showModelRefreshStatus(refreshButton, false, message);
      }
    } catch (error) {
      logger.error("Error fetching models:", error);
      this.showModelRefreshStatus(refreshButton, false, "Failed to fetch models");
    }
  }
  /**
   * Refresh models button handler
   */
  async refreshModels(dropdown, refreshButton) {
    refreshButton.textContent = "\u23F3";
    refreshButton.disabled = true;
    try {
      await this.fetchAndUpdateModels(this.plugin.settings.aiProvider, dropdown, refreshButton);
    } finally {
      refreshButton.textContent = "\u{1F504}";
      refreshButton.disabled = false;
    }
  }
  /**
   * Show model refresh status with temporary visual feedback
   */
  showModelRefreshStatus(button, success, message) {
    const originalText = button.textContent;
    const originalColor = button.style.color;
    button.textContent = success ? "\u2705" : "\u274C";
    button.style.color = success ? "var(--color-green)" : "var(--color-red)";
    button.title = message;
    setTimeout(() => {
      button.textContent = originalText;
      button.style.color = originalColor;
      button.title = "Refresh available models from endpoint";
    }, 2e3);
  }
  refreshAIConfigSettings() {
    this.aiConfigContainer.empty();
    const provider = this.plugin.settings.aiProvider;
    const requirements = AIServiceFactory.getProviderRequirements(provider);
    this.aiConfigContainer.createEl("p", {
      text: requirements.description,
      cls: "setting-item-description"
    });
    if (requirements.requiresApiKey) {
      new import_obsidian.Setting(this.aiConfigContainer).setName("API Key").setDesc("Your API key for the selected provider").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.aiConfig.apiKey || "").onChange(async (value) => {
        this.plugin.settings.aiConfig.apiKey = value.trim();
        await this.plugin.saveSettings();
        this.triggerModelRefresh();
      }));
    }
    if (requirements.requiresEndpoint) {
      new import_obsidian.Setting(this.aiConfigContainer).setName("Endpoint URL").setDesc("URL of your Ollama server").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.aiConfig.endpoint || "http://localhost:11434").onChange(async (value) => {
        this.plugin.settings.aiConfig.endpoint = value.trim() || "http://localhost:11434";
        await this.plugin.saveSettings();
        this.triggerModelRefresh();
      }));
    }
  }
  /**
   * Trigger model refresh after configuration changes
   */
  triggerModelRefresh() {
    var _a;
    const modelDropdowns = this.containerEl.querySelectorAll(".dropdown");
    const refreshButtons = this.containerEl.querySelectorAll('button[title*="Refresh"]');
    if (modelDropdowns.length >= 2 && refreshButtons.length > 0) {
      const modelDropdown = (_a = modelDropdowns[1]) == null ? void 0 : _a.__component;
      const refreshButton = refreshButtons[0];
      if (modelDropdown && refreshButton) {
        setTimeout(() => {
          this.fetchAndUpdateModels(this.plugin.settings.aiProvider, modelDropdown, refreshButton);
        }, 500);
      }
    }
  }
  addSchedulingSettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Scheduling" });
    new import_obsidian.Setting(containerEl).setName("Check frequency").setDesc("How often to check for new daily notes (in minutes)").addSlider((slider) => slider.setLimits(5, 1440, 5).setValue(this.plugin.settings.checkFrequency).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.checkFrequency = value;
      await this.plugin.saveSettings();
    })).addText((text) => text.setValue(this.plugin.settings.checkFrequency.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue >= 5 && numValue <= 1440) {
        this.plugin.settings.checkFrequency = numValue;
        await this.plugin.saveSettings();
      }
    }));
  }
  addAdvancedSettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Advanced Settings" });
    new import_obsidian.Setting(containerEl).setName("Custom prompt").setDesc("Custom prompt for AI processing. Use {content} placeholder for log entries.").addTextArea((text) => {
      text.setPlaceholder("Enter your custom prompt...").setValue(this.plugin.settings.customPrompt).onChange(async (value) => {
        this.plugin.settings.customPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 8;
      text.inputEl.style.width = "100%";
      text.inputEl.style.minHeight = "150px";
    });
    new import_obsidian.Setting(containerEl).setName("Dynamic processing").setDesc("Notes are processed dynamically based on journal file existence. To reprocess a note, delete its corresponding journal file.").addButton((button) => button.setButtonText("Info").setDisabled(true).onClick(() => {
    }));
  }
  addActionButtons() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Actions" });
    new import_obsidian.Setting(containerEl).setName("Test AI connection").setDesc("Test if your AI configuration is working").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      button.setButtonText("Testing...");
      button.setDisabled(true);
      try {
        const result = await this.plugin.scheduler.testAIConnection();
        const statusEl = containerEl.createEl("div", {
          text: result.success ? "\u2705 Connection successful!" : `\u274C Connection failed: ${result.error}`,
          cls: result.success ? "mod-success" : "mod-error"
        });
        setTimeout(() => statusEl.remove(), 5e3);
      } catch (error) {
        const statusEl = containerEl.createEl("div", {
          text: `\u274C Test failed: ${error.message}`,
          cls: "mod-error"
        });
        setTimeout(() => statusEl.remove(), 5e3);
      } finally {
        button.setButtonText("Test Connection");
        button.setDisabled(false);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Process notes now").setDesc("Manually trigger processing of daily notes").addButton((button) => button.setButtonText("Process Now").onClick(async () => {
      button.setButtonText("Processing...");
      button.setDisabled(true);
      try {
        const result = await this.plugin.scheduler.processNotes();
        const statusEl = containerEl.createEl("div", {
          text: `\u2705 Processed ${result.processed} notes in ${(result.duration / 1e3).toFixed(1)}s`,
          cls: "mod-success"
        });
        if (result.errors.length > 0) {
          statusEl.innerHTML += `<br>\u26A0\uFE0F ${result.errors.length} errors occurred`;
          statusEl.className = "mod-warning";
        }
        setTimeout(() => statusEl.remove(), 5e3);
      } catch (error) {
        const statusEl = containerEl.createEl("div", {
          text: `\u274C Processing failed: ${error.message}`,
          cls: "mod-error"
        });
        setTimeout(() => statusEl.remove(), 5e3);
      } finally {
        button.setButtonText("Process Now");
        button.setDisabled(false);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Validate configuration").setDesc("Check if all settings are correct").addButton((button) => button.setButtonText("Validate").onClick(async () => {
      const validation = await this.plugin.scheduler.validateConfiguration();
      let message = "";
      let className = "";
      if (validation.valid) {
        message = "\u2705 Configuration is valid!";
        className = "mod-success";
      } else {
        message = `\u274C Configuration errors:
${validation.errors.join("\n")}`;
        className = "mod-error";
      }
      if (validation.warnings.length > 0) {
        message += `
\u26A0\uFE0F Warnings:
${validation.warnings.join("\n")}`;
        if (className === "mod-success")
          className = "mod-warning";
      }
      const statusEl = containerEl.createEl("pre", {
        text: message,
        cls: className
      });
      statusEl.style.whiteSpace = "pre-wrap";
      statusEl.style.fontSize = "12px";
      setTimeout(() => statusEl.remove(), 1e4);
    }));
  }
};

// src/utils/dateUtils.ts
var import_obsidian2 = require("obsidian");
var DateUtils = class {
  /**
   * Parse date from filename using the specified format
   */
  static parseDateFromFilename(filename, format) {
    try {
      const nameWithoutExtension = filename.replace(/\.[^/.]+$/, "");
      const parsedDate = (0, import_obsidian2.moment)(nameWithoutExtension, format);
      if (parsedDate.isValid()) {
        return parsedDate.toDate();
      }
      return null;
    } catch (error) {
      console.error("Error parsing date from filename:", error);
      return null;
    }
  }
  /**
   * Format date using the specified format
   */
  static formatDate(date, format) {
    return (0, import_obsidian2.moment)(date).format(format);
  }
  /**
   * Check if a date is before today
   */
  static isBeforeToday(date) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const compareDate = new Date(date);
    compareDate.setHours(0, 0, 0, 0);
    return compareDate < today;
  }
  /**
   * Generate filename from date and format template
   */
  static generateFilename(date, template) {
    let result = template;
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const monthNamesShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const dayNamesShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const replacements = {
      "YYYY": year.toString(),
      "YY": year.toString().slice(-2),
      "MMMM": monthNames[month - 1],
      "MMM": monthNamesShort[month - 1],
      "MM": month.toString().padStart(2, "0"),
      "DD": day.toString().padStart(2, "0"),
      "HH": hours.toString().padStart(2, "0"),
      "hh": (hours % 12 || 12).toString().padStart(2, "0"),
      "mm": minutes.toString().padStart(2, "0"),
      "ss": seconds.toString().padStart(2, "0"),
      "dddd": dayNames[date.getDay()],
      "ddd": dayNamesShort[date.getDay()],
      // Only include single letter tokens that are unlikely to appear in literal text
      "M": month.toString(),
      "D": day.toString(),
      "H": hours.toString(),
      "h": (hours % 12 || 12).toString()
      // Removed 'A', 'a' tokens as they conflict with literal text like "Journal" and "amazing"
    };
    const sortedTokens = Object.keys(replacements).sort((a, b) => b.length - a.length);
    for (const token of sortedTokens) {
      result = result.replace(new RegExp(token, "g"), replacements[token]);
    }
    result = this.sanitizeFilename(result);
    return result;
  }
  /**
   * Sanitize filename to ensure it's valid for the file system
   */
  static sanitizeFilename(filename) {
    return filename.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").replace(/^\.+/, "").replace(/\.+$/, ".md").trim();
  }
  /**
   * Extract date formats from common patterns
   */
  static inferDateFormat(filename) {
    const commonFormats = [
      "YYYY-MM-DD",
      "YYYY_MM_DD",
      "DD-MM-YYYY",
      "MM-DD-YYYY",
      "YYYYMMDD",
      "DD.MM.YYYY",
      "MM.DD.YYYY"
    ];
    const nameWithoutExtension = filename.replace(/\.[^/.]+$/, "");
    for (const format of commonFormats) {
      const parsed = (0, import_obsidian2.moment)(nameWithoutExtension, format);
      if (parsed.isValid()) {
        return format;
      }
    }
    return null;
  }
};

// src/utils/fileUtils.ts
var import_obsidian3 = require("obsidian");
var import_crypto = require("crypto");
var FileUtils = class {
  /**
   * Get or create a folder
   */
  static async ensureFolder(app, folderPath) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(folderPath);
    let folder = app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      await app.vault.createFolder(normalizedPath);
      folder = app.vault.getAbstractFileByPath(normalizedPath);
    }
    if (!(folder instanceof import_obsidian3.TFolder)) {
      throw new Error(`Path exists but is not a folder: ${normalizedPath}`);
    }
    return folder;
  }
  /**
   * Get all files in a folder with optional extension filter
   */
  static getFilesInFolder(app, folderPath, extension) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(folderPath);
    const folder = app.vault.getAbstractFileByPath(normalizedPath);
    if (!(folder instanceof import_obsidian3.TFolder)) {
      return [];
    }
    const files = [];
    const collectFiles = (currentFolder) => {
      for (const child of currentFolder.children) {
        if (child instanceof import_obsidian3.TFile) {
          if (!extension || child.extension === extension) {
            files.push(child);
          }
        } else if (child instanceof import_obsidian3.TFolder) {
          collectFiles(child);
        }
      }
    };
    collectFiles(folder);
    return files;
  }
  /**
   * Check if a file exists
   */
  static fileExists(app, filePath) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(filePath);
    const file = app.vault.getAbstractFileByPath(normalizedPath);
    return file instanceof import_obsidian3.TFile;
  }
  /**
   * Create a file with content
   */
  static async createFile(app, filePath, content) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(filePath);
    const parentPath = normalizedPath.substring(0, normalizedPath.lastIndexOf("/"));
    if (parentPath) {
      await this.ensureFolder(app, parentPath);
    }
    return await app.vault.create(normalizedPath, content);
  }
  /**
   * Read file content
   */
  static async readFile(app, file) {
    return await app.vault.read(file);
  }
  /**
   * Update file content
   */
  static async updateFile(app, file, content) {
    await app.vault.modify(file, content);
  }
  /**
   * Generate a hash for content to detect changes
   */
  static generateContentHash(content) {
    return (0, import_crypto.createHash)("md5").update(content).digest("hex");
  }
  /**
   * Parse frontmatter from markdown content
   */
  static parseFrontmatter(content) {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return { frontmatter: {}, body: content };
    }
    try {
      const frontmatter = this.parseYaml(match[1]);
      return { frontmatter, body: match[2] };
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      return { frontmatter: {}, body: content };
    }
  }
  /**
   * Add frontmatter to content
   */
  static addFrontmatter(content, frontmatter) {
    if (Object.keys(frontmatter).length === 0) {
      return content;
    }
    const yamlString = this.stringifyYaml(frontmatter);
    return `---
${yamlString}
---

${content}`;
  }
  /**
   * Simple YAML parser for frontmatter
   */
  static parseYaml(yamlString) {
    const result = {};
    const lines = yamlString.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const colonIndex = trimmed.indexOf(":");
      if (colonIndex === -1)
        continue;
      const key = trimmed.substring(0, colonIndex).trim();
      const value = trimmed.substring(colonIndex + 1).trim();
      if (value.startsWith('"') && value.endsWith('"')) {
        result[key] = value.slice(1, -1);
      } else if (value === "true") {
        result[key] = true;
      } else if (value === "false") {
        result[key] = false;
      } else if (!isNaN(Number(value))) {
        result[key] = Number(value);
      } else {
        result[key] = value;
      }
    }
    return result;
  }
  /**
   * Simple YAML stringifier for frontmatter
   */
  static stringifyYaml(obj) {
    const lines = [];
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string") {
        lines.push(`${key}: "${value}"`);
      } else if (Array.isArray(value)) {
        lines.push(`${key}:`);
        for (const item of value) {
          lines.push(`  - ${typeof item === "string" ? `"${item}"` : item}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    return lines.join("\n");
  }
  /**
   * Sanitize filename to ensure it's valid for the file system
   */
  static sanitizeFilename(filename) {
    return filename.replace(/[<>:"/\\|?*]/g, "_");
  }
};

// src/utils/coordinateParser.ts
var CoordinateParser = class {
  /**
   * Extract all coordinates from text content
   */
  static extractCoordinates(content) {
    const coordinates = [];
    const processedRaws = /* @__PURE__ */ new Set();
    for (const pattern of this.COORDINATE_PATTERNS) {
      let match;
      const regex = new RegExp(pattern.source, pattern.flags);
      while ((match = regex.exec(content)) !== null) {
        const raw = match[0];
        if (processedRaws.has(raw)) {
          continue;
        }
        processedRaws.add(raw);
        let lat, lng;
        if (match.length === 3) {
          lat = parseFloat(match[1]);
          lng = parseFloat(match[2]);
        } else if (match.length === 5) {
          lat = parseFloat(match[1]);
          lng = parseFloat(match[3]);
          if (match[2].toUpperCase() === "S")
            lat = -lat;
          if (match[4].toUpperCase() === "W")
            lng = -lng;
        } else {
          continue;
        }
        if (this.isValidCoordinate(lat, lng)) {
          coordinates.push({
            lat,
            lng,
            raw
          });
        }
      }
    }
    return coordinates;
  }
  /**
   * Remove coordinate strings from content
   */
  static removeCoordinatesFromContent(content) {
    let cleanContent = content;
    for (const pattern of this.COORDINATE_PATTERNS) {
      cleanContent = cleanContent.replace(pattern, "").trim();
    }
    cleanContent = cleanContent.replace(/\s+/g, " ").replace(/\n\s*\n/g, "\n").trim();
    return cleanContent;
  }
  /**
   * Validate if coordinates are within valid ranges
   */
  static isValidCoordinate(lat, lng) {
    return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
  }
  /**
   * Format coordinates for YAML frontmatter
   */
  static formatCoordinatesForYaml(coordinates) {
    if (coordinates.length === 0) {
      return "";
    }
    const locationStrings = coordinates.map((coord) => `"[${coord.lat}, ${coord.lng}]"`);
    if (locationStrings.length === 1) {
      return `location: ${locationStrings[0]}`;
    } else {
      return `locations:
${locationStrings.map((loc) => `  - ${loc}`).join("\n")}`;
    }
  }
  /**
   * Convert coordinates to a readable format
   */
  static coordinatesToReadableFormat(coordinate) {
    const latDir = coordinate.lat >= 0 ? "N" : "S";
    const lngDir = coordinate.lng >= 0 ? "E" : "W";
    return `${Math.abs(coordinate.lat)}\xB0${latDir}, ${Math.abs(coordinate.lng)}\xB0${lngDir}`;
  }
};
// Common coordinate patterns
CoordinateParser.COORDINATE_PATTERNS = [
  // [lat, lng] format
  /\[(-?\d+\.?\d*),\s*(-?\d+\.?\d*)\]/g,
  // (lat, lng) format
  /\((-?\d+\.?\d*),\s*(-?\d+\.?\d*)\)/g,
  // lat, lng format
  /(-?\d+\.?\d*),\s*(-?\d+\.?\d*)/g,
  // Decimal degrees with direction
  /(\d+\.?\d*)[°]?\s*([NS])\s*,?\s*(\d+\.?\d*)[°]?\s*([EW])/gi,
  // GPS coordinates
  /GPS:\s*(-?\d+\.?\d*),\s*(-?\d+\.?\d*)/gi,
  // Location: format
  /Location:\s*(-?\d+\.?\d*),\s*(-?\d+\.?\d*)/gi
];

// src/services/noteProcessor.ts
var NoteProcessor = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Find the most recent daily note (excluding today) for testing
   */
  async findMostRecentDailyNote() {
    logger.debug("Finding most recent daily note for testing");
    try {
      const files = FileUtils.getFilesInFolder(this.app, this.settings.sourceFolder, "md");
      let mostRecentNote = null;
      for (const file of files) {
        try {
          const date = DateUtils.parseDateFromFilename(file.name, this.settings.dateFormat);
          if (!date) {
            logger.debug(`Could not parse date from filename: ${file.name}`);
            continue;
          }
          if (!DateUtils.isBeforeToday(date)) {
            logger.debug(`Skipping future/today note: ${file.name}`);
            continue;
          }
          if (!mostRecentNote || date > mostRecentNote.date) {
            mostRecentNote = { file, date };
          }
        } catch (error) {
          logger.error(`Error processing file ${file.name}:`, error);
        }
      }
      if (!mostRecentNote) {
        logger.info("No past daily notes found for testing");
        return null;
      }
      logger.info(`Found most recent daily note: ${mostRecentNote.file.name} (${mostRecentNote.date.toDateString()})`);
      if (await this.journalEntryExists(mostRecentNote.date)) {
        logger.info(`Journal already exists for date: ${DateUtils.formatDate(mostRecentNote.date, this.settings.dateFormat)}`);
        return null;
      }
      const dailyNote = await this.parseDailyNote(mostRecentNote.file, mostRecentNote.date);
      if (dailyNote.entries.length === 0) {
        logger.debug(`No log entries found in: ${mostRecentNote.file.name}`);
        return null;
      }
      return dailyNote;
    } catch (error) {
      logger.error("Error finding most recent daily note:", error);
      throw new Error(`Failed to find recent daily note: ${error.message}`);
    }
  }
  async findUnprocessedDailyNotes() {
    logger.debug("Scanning for unprocessed daily notes");
    try {
      const files = FileUtils.getFilesInFolder(this.app, this.settings.sourceFolder, "md");
      const unprocessedNotes = [];
      let processedCount = 0;
      let skippedCount = 0;
      for (const file of files) {
        try {
          const date = DateUtils.parseDateFromFilename(file.name, this.settings.dateFormat);
          if (!date) {
            logger.debug(`Could not parse date from filename: ${file.name}`);
            skippedCount++;
            continue;
          }
          if (!DateUtils.isBeforeToday(date)) {
            logger.debug(`Skipping future/today note: ${file.name}`);
            skippedCount++;
            continue;
          }
          if (await this.journalEntryExists(date)) {
            logger.debug(`Journal already exists for date: ${DateUtils.formatDate(date, this.settings.dateFormat)}`);
            skippedCount++;
            continue;
          }
          const dailyNote = await this.parseDailyNote(file, date);
          if (dailyNote.entries.length === 0) {
            logger.debug(`No log entries found in: ${file.name}`);
            skippedCount++;
            continue;
          }
          unprocessedNotes.push(dailyNote);
          processedCount++;
        } catch (error) {
          logger.error(`Error processing file ${file.name}:`, error);
          skippedCount++;
        }
      }
      logger.logProcessingStats(processedCount, skippedCount, 0);
      logger.info(`Found ${unprocessedNotes.length} daily notes to process`);
      return unprocessedNotes;
    } catch (error) {
      logger.error("Error scanning for daily notes:", error);
      throw new Error(`Failed to scan daily notes: ${error.message}`);
    }
  }
  /**
   * Parse a daily note file into structured data
   */
  async parseDailyNote(file, date) {
    const content = await FileUtils.readFile(this.app, file);
    const entries = this.parseLogEntries(content);
    const coordinates = CoordinateParser.extractCoordinates(content);
    return {
      file: file.path,
      date: DateUtils.formatDate(date, "YYYY-MM-DD"),
      entries,
      coordinates
    };
  }
  /**
   * Parse log entries from note content
   */
  parseLogEntries(content) {
    const entries = [];
    const { body } = FileUtils.parseFrontmatter(content);
    const lines = body.split("\n");
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.startsWith("#") || trimmedLine.startsWith("---") || trimmedLine.startsWith("<!--") || trimmedLine.length < 5) {
        continue;
      }
      let cleanLine = trimmedLine.replace(/^[-*+]\s*/, "").replace(/^\d+\.\s*/, "").replace(/^- \[[x\s]\]\s*/, "").replace(/^\[\s*\]\s*/, "").replace(/^\[x\]\s*/, "").trim();
      if (cleanLine.length < 5) {
        continue;
      }
      const lineCoordinates = CoordinateParser.extractCoordinates(cleanLine);
      const cleanContent = CoordinateParser.removeCoordinatesFromContent(cleanLine);
      if (cleanContent.trim().length > 0) {
        entries.push({
          content: cleanContent.trim(),
          coordinates: lineCoordinates.length > 0 ? lineCoordinates[0] : void 0
        });
      }
    }
    return entries;
  }
  /**
   * Check if a journal entry already exists for the given date
   */
  async journalEntryExists(date) {
    const journalFileName = DateUtils.generateFilename(date, this.settings.journalFileNameFormat);
    const journalPath = `${this.settings.destinationFolder}/${journalFileName}`;
    return FileUtils.fileExists(this.app, journalPath);
  }
  /**
   * Get processing statistics
   */
  getProcessingStats() {
    return {
      totalProcessed: 0
      // We no longer track this
      // We could add a lastProcessingTime field to settings if needed
    };
  }
  /**
   * Reset processing history (for debugging/testing)
   * Note: This is now a no-op since we use dynamic checking
   */
  resetProcessingHistory() {
    logger.info("Reset processing history (no-op - using dynamic checking)");
  }
  /**
   * Update settings (when settings change)
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
    logger.debug("Updated note processor settings");
  }
  /**
   * Validate that the source folder exists and is accessible
   */
  async validateSourceFolder() {
    try {
      const files = FileUtils.getFilesInFolder(this.app, this.settings.sourceFolder, "md");
      return {
        valid: true,
        fileCount: files.length
      };
    } catch (error) {
      return {
        valid: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
};

// src/services/journalManager.ts
var JournalManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Create a journal entry from processed AI content
   */
  async createJournalEntry(dailyNote, processedContent, sentiment) {
    logger.debug(`Creating journal entry for date: ${dailyNote.date}`);
    try {
      const dateParts = dailyNote.date.split("-");
      const date = new Date(
        parseInt(dateParts[0]),
        // year
        parseInt(dateParts[1]) - 1,
        // month (0-indexed)
        parseInt(dateParts[2])
        // day
      );
      logger.debug(`Parsed date: ${date.toISOString()}`);
      logger.debug(`Local date components: ${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`);
      logger.debug(`Journal filename format: ${this.settings.journalFileNameFormat}`);
      logger.debug(`Destination folder: ${this.settings.destinationFolder}`);
      const journalFileName = DateUtils.generateFilename(date, this.settings.journalFileNameFormat);
      logger.debug(`Generated filename: ${journalFileName}`);
      const journalPath = `${this.settings.destinationFolder}/${journalFileName}`;
      logger.debug(`Full journal path: ${journalPath}`);
      const journalEntry = {
        title: this.generateTitle(date),
        content: processedContent,
        date: dailyNote.date,
        coordinates: dailyNote.coordinates,
        sourceFile: dailyNote.file,
        sentiment
      };
      const formattedContent = this.formatJournalContent(journalEntry);
      await FileUtils.ensureFolder(this.app, this.settings.destinationFolder);
      if (FileUtils.fileExists(this.app, journalPath)) {
        logger.info(`Updating existing journal entry: ${journalPath}`);
        const existingFile = this.app.vault.getAbstractFileByPath(journalPath);
        await FileUtils.updateFile(this.app, existingFile, formattedContent);
      } else {
        logger.info(`Creating new journal entry: ${journalPath}`);
        await FileUtils.createFile(this.app, journalPath, formattedContent);
      }
      logger.logFileOperation("created/updated", journalPath);
      return journalEntry;
    } catch (error) {
      logger.error(`Failed to create journal entry for ${dailyNote.date}:`, error);
      throw new Error(`Failed to create journal entry: ${error.message}`);
    }
  }
  /**
   * Format journal content with frontmatter and structure
   */
  formatJournalContent(journalEntry) {
    const frontmatter = {
      date: journalEntry.date,
      source: journalEntry.sourceFile,
      created: new Date().toISOString()
    };
    if (journalEntry.sentiment) {
      frontmatter.sentiment = journalEntry.sentiment;
    }
    if (journalEntry.coordinates.length > 0) {
      const locationYaml = CoordinateParser.formatCoordinatesForYaml(journalEntry.coordinates);
      if (locationYaml) {
        if (journalEntry.coordinates.length === 1) {
          frontmatter.location = `[${journalEntry.coordinates[0].lat}, ${journalEntry.coordinates[0].lng}]`;
        } else {
          frontmatter.locations = journalEntry.coordinates.map(
            (coord) => `[${coord.lat}, ${coord.lng}]`
          );
        }
      }
    }
    let content = journalEntry.content;
    content = content.replace(/\n{3,}/g, "\n\n");
    const finalContent = journalEntry.title ? `# ${journalEntry.title}

${content}` : content;
    return FileUtils.addFrontmatter(finalContent, frontmatter);
  }
  /**
   * Generate a title for the journal entry
   */
  generateTitle(date) {
    const dateString = DateUtils.formatDate(date, "MMMM Do, YYYY");
    return dateString;
  }
  /**
   * Get existing journal entry for a date
   */
  async getExistingJournalEntry(date) {
    const journalFileName = DateUtils.generateFilename(date, this.settings.journalFileNameFormat);
    const journalPath = `${this.settings.destinationFolder}/${journalFileName}`;
    if (!FileUtils.fileExists(this.app, journalPath)) {
      return { exists: false };
    }
    const file = this.app.vault.getAbstractFileByPath(journalPath);
    const content = await FileUtils.readFile(this.app, file);
    return {
      exists: true,
      file,
      content
    };
  }
  /**
   * Backup an existing journal entry before overwriting
   */
  async backupJournalEntry(file) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const backupPath = `${file.path}.backup-${timestamp}`;
    const content = await FileUtils.readFile(this.app, file);
    await FileUtils.createFile(this.app, backupPath, content);
    logger.info(`Created backup: ${backupPath}`);
    return backupPath;
  }
  /**
   * Validate destination folder and create if needed
   */
  async validateAndCreateDestination() {
    try {
      const folder = await FileUtils.ensureFolder(this.app, this.settings.destinationFolder);
      return {
        valid: true,
        created: true
      };
    } catch (error) {
      return {
        valid: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Get journal statistics
   */
  async getJournalStats() {
    try {
      const files = FileUtils.getFilesInFolder(this.app, this.settings.destinationFolder, "md");
      const sortedFiles = files.sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, 10);
      return {
        totalJournals: files.length,
        recentJournals: sortedFiles.map((f) => f.name)
      };
    } catch (error) {
      logger.error("Error getting journal stats:", error);
      return {
        totalJournals: 0,
        recentJournals: []
      };
    }
  }
  /**
   * Preview journal content before creation
   */
  previewJournalContent(dailyNote, processedContent, sentiment) {
    const date = new Date(dailyNote.date);
    const journalEntry = {
      title: this.generateTitle(date),
      content: processedContent,
      date: dailyNote.date,
      coordinates: dailyNote.coordinates,
      sourceFile: dailyNote.file,
      sentiment
    };
    return this.formatJournalContent(journalEntry);
  }
  /**
   * Update settings
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
    logger.debug("Updated journal manager settings");
  }
  /**
   * Clean up old journal entries (if needed)
   */
  async cleanupOldJournals(daysToKeep) {
    if (!daysToKeep) {
      return 0;
    }
    try {
      const files = FileUtils.getFilesInFolder(this.app, this.settings.destinationFolder, "md");
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
      let deletedCount = 0;
      for (const file of files) {
        if (file.stat.mtime < cutoffDate.getTime()) {
          await this.app.vault.delete(file);
          deletedCount++;
          logger.info(`Deleted old journal: ${file.path}`);
        }
      }
      return deletedCount;
    } catch (error) {
      logger.error("Error cleaning up old journals:", error);
      throw error;
    }
  }
};

// src/services/scheduler.ts
var Scheduler = class {
  constructor(app, settings, noteProcessor, journalManager) {
    this.intervalId = null;
    this.isProcessing = false;
    this.lastProcessingTime = null;
    this.app = app;
    this.settings = settings;
    this.noteProcessor = noteProcessor;
    this.journalManager = journalManager;
  }
  /**
   * Start the periodic processing
   */
  start() {
    this.stop();
    if (this.settings.checkFrequency <= 0) {
      logger.warn("Invalid check frequency, scheduling disabled");
      return;
    }
    const intervalMs = this.settings.checkFrequency * 60 * 1e3;
    logger.info(`Starting scheduler with ${this.settings.checkFrequency} minute intervals`);
    this.intervalId = window.setInterval(() => {
      this.processNotes();
    }, intervalMs);
    setTimeout(() => {
      this.processNotes();
    }, 5e3);
  }
  /**
   * Stop the periodic processing
   */
  stop() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
      logger.info("Scheduler stopped");
    }
  }
  /**
   * Process the most recent daily note for testing purposes
   */
  async processLatestNote() {
    if (this.isProcessing) {
      logger.warn("Processing already in progress, skipping");
      return {
        success: false,
        processed: 0,
        errors: ["Processing already in progress"],
        duration: 0
      };
    }
    this.isProcessing = true;
    const startTime = Date.now();
    const errors = [];
    try {
      logger.info("Starting latest note processing for testing");
      const mostRecentNote = await this.noteProcessor.findMostRecentDailyNote();
      if (!mostRecentNote) {
        logger.info("No recent daily note found to process");
        return {
          success: true,
          processed: 0,
          errors: ["No recent daily note found"],
          duration: Date.now() - startTime
        };
      }
      logger.info(`Processing latest note: ${mostRecentNote.file}`);
      const aiService = AIServiceFactory.createService(this.settings.aiProvider, this.settings.aiConfig);
      const logContent = this.prepareContentForAI(mostRecentNote);
      if (!logContent.trim()) {
        logger.warn(`No content to process in: ${mostRecentNote.file}`);
        return {
          success: false,
          processed: 0,
          errors: ["No processable content found in the note"],
          duration: Date.now() - startTime
        };
      }
      const aiResponse = await aiService.processContent(
        logContent,
        this.settings.customPrompt,
        this.settings.outputLanguage === "auto" ? void 0 : this.settings.outputLanguage
      );
      await this.journalManager.createJournalEntry(mostRecentNote, aiResponse.content, aiResponse.sentiment);
      this.lastProcessingTime = new Date();
      const duration = Date.now() - startTime;
      const result = {
        success: true,
        processed: 1,
        errors: [],
        duration
      };
      logger.info(`Successfully processed latest note: ${mostRecentNote.file}`);
      logger.logProcessingStats(1, 0, 0);
      return result;
    } catch (error) {
      const errorMessage = `Latest note processing failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      logger.error(errorMessage, error);
      return {
        success: false,
        processed: 0,
        errors: [errorMessage, ...errors],
        duration: Date.now() - startTime
      };
    } finally {
      this.isProcessing = false;
    }
  }
  async processNotes() {
    if (this.isProcessing) {
      logger.warn("Processing already in progress, skipping");
      return {
        success: false,
        processed: 0,
        errors: ["Processing already in progress"],
        duration: 0
      };
    }
    this.isProcessing = true;
    const startTime = Date.now();
    let processedCount = 0;
    const errors = [];
    try {
      logger.info("Starting note processing cycle");
      const unprocessedNotes = await this.noteProcessor.findUnprocessedDailyNotes();
      if (unprocessedNotes.length === 0) {
        logger.info("No notes to process");
        return {
          success: true,
          processed: 0,
          errors: [],
          duration: Date.now() - startTime
        };
      }
      logger.info(`Found ${unprocessedNotes.length} notes to process`);
      const aiService = AIServiceFactory.createService(this.settings.aiProvider, this.settings.aiConfig);
      for (const dailyNote of unprocessedNotes) {
        try {
          logger.debug(`Processing note: ${dailyNote.file}`);
          const logContent = this.prepareContentForAI(dailyNote);
          if (!logContent.trim()) {
            logger.warn(`No content to process in: ${dailyNote.file}`);
            continue;
          }
          const aiResponse = await aiService.processContent(
            logContent,
            this.settings.customPrompt,
            this.settings.outputLanguage === "auto" ? void 0 : this.settings.outputLanguage
          );
          await this.journalManager.createJournalEntry(dailyNote, aiResponse.content, aiResponse.sentiment);
          processedCount++;
          logger.info(`Successfully processed: ${dailyNote.file}`);
        } catch (error) {
          const errorMessage = `Failed to process ${dailyNote.file}: ${error instanceof Error ? error.message : "Unknown error"}`;
          logger.error(errorMessage, error);
          errors.push(errorMessage);
        }
      }
      this.lastProcessingTime = new Date();
      const duration = Date.now() - startTime;
      const result = {
        success: errors.length === 0,
        processed: processedCount,
        errors,
        duration
      };
      logger.logProcessingStats(processedCount, unprocessedNotes.length - processedCount, errors.length);
      return result;
    } catch (error) {
      const errorMessage = `Processing cycle failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      logger.error(errorMessage, error);
      return {
        success: false,
        processed: processedCount,
        errors: [errorMessage, ...errors],
        duration: Date.now() - startTime
      };
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Prepare daily note content for AI processing
   */
  prepareContentForAI(dailyNote) {
    const entries = dailyNote.entries || [];
    if (entries.length === 0) {
      return "";
    }
    const logEntries = entries.map((entry) => entry.content).join("\n");
    return logEntries.trim();
  }
  /**
   * Get scheduler status
   */
  getStatus() {
    let nextProcessingTime = null;
    if (this.intervalId !== null && this.lastProcessingTime) {
      nextProcessingTime = new Date(
        this.lastProcessingTime.getTime() + this.settings.checkFrequency * 60 * 1e3
      );
    }
    return {
      isRunning: this.intervalId !== null,
      isProcessing: this.isProcessing,
      lastProcessingTime: this.lastProcessingTime,
      nextProcessingTime
    };
  }
  /**
   * Update settings and restart if needed
   */
  updateSettings(newSettings) {
    const wasRunning = this.intervalId !== null;
    const frequencyChanged = this.settings.checkFrequency !== newSettings.checkFrequency;
    this.settings = newSettings;
    this.noteProcessor.updateSettings(newSettings);
    this.journalManager.updateSettings(newSettings);
    if (wasRunning && frequencyChanged) {
      logger.info("Restarting scheduler due to frequency change");
      this.start();
    }
  }
  /**
   * Test AI service connection
   */
  async testAIConnection() {
    try {
      const result = await AIServiceFactory.testConnection(this.settings.aiProvider, this.settings.aiConfig);
      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Validate all configurations
   */
  async validateConfiguration() {
    const errors = [];
    const warnings = [];
    const aiErrors = AIServiceFactory.validateConfiguration(this.settings.aiProvider, this.settings.aiConfig);
    errors.push(...aiErrors);
    const sourceValidation = await this.noteProcessor.validateSourceFolder();
    if (!sourceValidation.valid) {
      errors.push(`Source folder error: ${sourceValidation.error}`);
    } else if (sourceValidation.fileCount === 0) {
      warnings.push("Source folder contains no markdown files");
    }
    const destValidation = await this.journalManager.validateAndCreateDestination();
    if (!destValidation.valid) {
      errors.push(`Destination folder error: ${destValidation.error}`);
    }
    if (this.settings.checkFrequency <= 0) {
      errors.push("Check frequency must be greater than 0");
    }
    if (!this.settings.customPrompt.trim()) {
      warnings.push("Custom prompt is empty, using default behavior");
    }
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * Force processing of a specific note by deleting its journal counterpart
   */
  async processSpecificNote(filePath) {
    try {
      const result = await this.processNotes();
      return {
        success: result.success && result.processed > 0
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
};

// src/main.ts
var JournalPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    logger.info("Loading Daily Notes to Journal plugin");
    try {
      await this.loadSettings();
      this.initializeServices();
      this.addSettingTab(new JournalPluginSettingTab(this.app, this));
      this.addCommands();
      this.scheduler.start();
      logger.info("Plugin loaded successfully");
    } catch (error) {
      logger.error("Failed to load plugin:", error);
      throw error;
    }
  }
  async onunload() {
    logger.info("Unloading Daily Notes to Journal plugin");
    if (this.scheduler) {
      this.scheduler.stop();
    }
    logger.info("Plugin unloaded");
  }
  initializeServices() {
    this.noteProcessor = new NoteProcessor(this.app, this.settings);
    this.journalManager = new JournalManager(this.app, this.settings);
    this.scheduler = new Scheduler(
      this.app,
      this.settings,
      this.noteProcessor,
      this.journalManager
    );
    logger.debug("Services initialized");
  }
  addCommands() {
    this.addCommand({
      id: "process-notes-now",
      name: "Process daily notes now",
      callback: async () => {
        try {
          logger.info("Manual processing triggered");
          const result = await this.scheduler.processNotes();
          if (result.success) {
            this.showNotice(`\u2705 Processed ${result.processed} notes in ${(result.duration / 1e3).toFixed(1)}s`);
          } else {
            this.showNotice(`\u274C Processing failed: ${result.errors[0] || "Unknown error"}`);
          }
        } catch (error) {
          logger.error("Manual processing failed:", error);
          this.showNotice(`\u274C Processing failed: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "process-latest-note",
      name: "Process latest daily note (test)",
      callback: async () => {
        try {
          logger.info("Latest note processing triggered for testing");
          const result = await this.scheduler.processLatestNote();
          if (result.success && result.processed > 0) {
            this.showNotice(`\u2705 Processed latest note in ${(result.duration / 1e3).toFixed(1)}s`);
          } else if (result.success && result.processed === 0) {
            this.showNotice(`\u2139\uFE0F ${result.errors[0] || "No notes to process"}`);
          } else {
            this.showNotice(`\u274C Processing failed: ${result.errors[0] || "Unknown error"}`);
          }
        } catch (error) {
          logger.error("Latest note processing failed:", error);
          this.showNotice(`\u274C Processing failed: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "show-latest-note-info",
      name: "Show latest daily note info",
      callback: async () => {
        try {
          const latestNote = await this.noteProcessor.findMostRecentDailyNote();
          if (!latestNote) {
            this.showNotice("\u2139\uFE0F No daily notes found from the past");
            return;
          }
          let message = `\u{1F4C4} Latest Daily Note Found:
`;
          message += `\u2022 File: ${latestNote.file}
`;
          message += `\u2022 Date: ${latestNote.date}
`;
          message += `\u2022 Entries: ${latestNote.entries.length} log entries
`;
          message += `\u2022 Coordinates: ${latestNote.coordinates.length} locations`;
          if (latestNote.entries.length > 0) {
            message += `

\u{1F50D} Preview:
${latestNote.entries[0].content.substring(0, 100)}...`;
          }
          this.showNotice(message, 8e3);
        } catch (error) {
          logger.error("Failed to find latest note:", error);
          this.showNotice(`\u274C Failed to find latest note: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "test-ai-connection",
      name: "Test AI connection",
      callback: async () => {
        try {
          const result = await this.scheduler.testAIConnection();
          if (result.success) {
            this.showNotice("\u2705 AI connection successful!");
          } else {
            this.showNotice(`\u274C AI connection failed: ${result.error}`);
          }
        } catch (error) {
          logger.error("AI connection test failed:", error);
          this.showNotice(`\u274C Test failed: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "show-processing-status",
      name: "Show processing status",
      callback: () => {
        const status = this.scheduler.getStatus();
        const stats = this.noteProcessor.getProcessingStats();
        let message = `\u{1F4CA} Processing Status:
`;
        message += `\u2022 Scheduler: ${status.isRunning ? "\u{1F7E2} Running" : "\u{1F534} Stopped"}
`;
        message += `\u2022 Currently processing: ${status.isProcessing ? "Yes" : "No"}
`;
        message += `\u2022 Total processed: ${stats.totalProcessed} notes
`;
        if (status.lastProcessingTime) {
          message += `\u2022 Last run: ${status.lastProcessingTime.toLocaleString()}
`;
        }
        if (status.nextProcessingTime) {
          message += `\u2022 Next run: ${status.nextProcessingTime.toLocaleString()}
`;
        }
        this.showNotice(message, 8e3);
      }
    });
    this.addCommand({
      id: "reset-processing-history",
      name: "Reset processing history (no-op)",
      callback: async () => {
        this.noteProcessor.resetProcessingHistory();
        this.showNotice("\u2139\uFE0F Processing is now dynamic - delete journal files to reprocess");
      }
    });
    this.addCommand({
      id: "validate-configuration",
      name: "Validate configuration",
      callback: async () => {
        const validation = await this.scheduler.validateConfiguration();
        if (validation.valid) {
          this.showNotice("\u2705 Configuration is valid!");
        } else {
          let message = "\u274C Configuration errors:\n";
          message += validation.errors.map((e) => `\u2022 ${e}`).join("\n");
          if (validation.warnings.length > 0) {
            message += "\n\u26A0\uFE0F Warnings:\n";
            message += validation.warnings.map((w) => `\u2022 ${w}`).join("\n");
          }
          this.showNotice(message, 1e4);
        }
      }
    });
    this.addCommand({
      id: "debug-filename-generation",
      name: "Debug filename generation",
      callback: () => {
        const testDate = new Date("2024-02-17");
        const template = this.settings.journalFileNameFormat;
        logger.info("=== Debugging Filename Generation ===");
        logger.info(`Test date: ${testDate.toISOString()}`);
        logger.info(`Template: ${template}`);
        logger.info(`Destination folder: ${this.settings.destinationFolder}`);
        const result = DateUtils.generateFilename(testDate, template);
        logger.info(`Generated filename: ${result}`);
        const fullPath = `${this.settings.destinationFolder}/${result}`;
        logger.info(`Full path: ${fullPath}`);
        this.showNotice(`Debug info logged to console.
Generated: ${result}
Full path: ${fullPath}`, 8e3);
      }
    });
  }
  async loadSettings() {
    const loadedSettings = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedSettings);
    logger.debug("Settings loaded");
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.noteProcessor) {
      this.noteProcessor.updateSettings(this.settings);
    }
    if (this.journalManager) {
      this.journalManager.updateSettings(this.settings);
    }
    if (this.scheduler) {
      this.scheduler.updateSettings(this.settings);
    }
    logger.debug("Settings saved and services updated");
  }
  showNotice(message, timeout = 5e3) {
    const noticeEl = document.createElement("div");
    noticeEl.className = "notice";
    noticeEl.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--background-primary);
      border: 1px solid var(--background-modifier-border);
      color: var(--text-normal);
      padding: 12px 16px;
      border-radius: 6px;
      box-shadow: var(--shadow-s);
      z-index: 1000;
      max-width: 400px;
      white-space: pre-line;
      font-family: var(--font-interface);
      font-size: var(--font-ui-small);
      line-height: 1.4;
    `;
    noticeEl.textContent = message;
    document.body.appendChild(noticeEl);
    setTimeout(() => {
      if (noticeEl.parentNode) {
        noticeEl.remove();
      }
    }, timeout);
    noticeEl.addEventListener("click", () => noticeEl.remove());
  }
  /**
   * Get plugin statistics
   */
  async getPluginStats() {
    var _a;
    const stats = this.noteProcessor.getProcessingStats();
    const journalStats = await this.journalManager.getJournalStats();
    const status = this.scheduler.getStatus();
    return {
      processed: stats.totalProcessed,
      journals: journalStats.totalJournals,
      status: status.isRunning ? "Running" : "Stopped",
      lastRun: (_a = status.lastProcessingTime) == null ? void 0 : _a.toISOString()
    };
  }
  /**
   * Process a specific note file
   */
  async processSpecificNote(filePath) {
    return await this.scheduler.processSpecificNote(filePath);
  }
  /**
   * Enable debug logging
   */
  enableDebugLogging() {
    logger.setLogLevel(0 /* DEBUG */);
    logger.info("Debug logging enabled");
  }
  /**
   * Disable debug logging
   */
  disableDebugLogging() {
    logger.setLogLevel(1 /* INFO */);
    logger.info("Debug logging disabled");
  }
};
